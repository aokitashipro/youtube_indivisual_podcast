---
alwaysApply: false
description:このファイルはYouTube AI Podcastプロジェクトのコーディング規約を定義します。
AIアシスタントは常にこの規約に従ってコードを生成・編集してください。

---

# コーディング規約

このファイルはYouTube AI Podcastプロジェクトのコーディング規約を定義します。
AIアシスタントは常にこの規約に従ってコードを生成・編集してください。

## 基本原則

1. **読みやすさ優先**: コードは人間が読むものです
2. **明示的に**: 暗黙的な動作は避ける
3. **エラーハンドリング必須**: すべての処理でエラーを適切に処理
4. **ログ出力必須**: 処理の開始・完了・エラーを必ずログに記録
5. **型ヒント使用**: 可能な限り型ヒントを使用

## ファイル構造

### インポートの順序（必須）
```python
# 1. 標準ライブラリ
import os
import sys
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime

# 2. サードパーティライブラリ
from dotenv import load_dotenv
import anthropic
import gspread

# 3. プロジェクト内インポート
from config.settings import Settings
from modules.xxx import Xxx
from utils.logger import setup_logger, get_logger
from utils.error_handler import ErrorHandler
from utils.timer import Timer, timer_context
```

### ファイルの先頭（必須）
```python
"""
モジュールの説明
"""
import 文...

# モジュールレベルのlogger取得
logger = get_logger(__name__)
```

## クラス定義

### クラスの基本構造
```python
class ClassName:
    """
    クラスの説明
    
    Attributes:
        attribute_name: 説明
    """
    
    def __init__(self, settings: Settings):
        """
        初期化
        
        Args:
            settings: アプリケーション設定
        """
        self.settings = settings
        # 初期化処理
        
    async def method_name(self, param: str) -> Dict[str, Any]:
        """
        メソッドの説明
        
        Args:
            param: パラメータの説明
            
        Returns:
            戻り値の説明
            
        Raises:
            Exception: エラーの説明
        """
        try:
            # 処理
            return result
        except Exception as e:
            logger.error(f"エラーメッセージ: {e}")
            raise
```

### 必須のdocstring形式
```python
"""
1行の要約

詳細な説明（必要に応じて）

Args:
    param1: パラメータ1の説明
    param2: パラメータ2の説明

Returns:
    戻り値の説明（型を含む）

Raises:
    ExceptionType: エラーが発生する条件
"""
```

## メソッド定義

### 非同期メソッド（推奨）
```python
async def method_name(self, param: str) -> Dict[str, Any]:
    """メソッドの説明"""
    with timer_context("処理名", logger):
        try:
            logger.info("🚀 処理を開始します")
            
            # メイン処理
            result = await some_async_operation(param)
            
            logger.info("✅ 処理が完了しました")
            return result
            
        except Exception as e:
            error_handler.handle_error(e, {"context": "method_name"})
            raise Exception(f"処理に失敗しました: {e}")
```

### 同期メソッド（必要な場合のみ）
```python
def method_name(self, param: str) -> Dict[str, Any]:
    """メソッドの説明"""
    try:
        logger.info("🚀 処理を開始します")
        
        # メイン処理
        result = some_operation(param)
        
        logger.info("✅ 処理が完了しました")
        return result
        
    except Exception as e:
        logger.error(f"❌ 処理に失敗しました: {e}")
        raise
```

### プライベートメソッド
```python
def _private_method(self, param: str) -> str:
    """
    内部処理用メソッド
    
    Note:
        このメソッドは外部から呼び出さないでください
    """
    # 処理
    return result
```

## 型ヒント

### 基本的な型ヒント
```python
# 必須: 引数と戻り値に型ヒント
def method(self, text: str, count: int) -> Dict[str, Any]:
    pass

# List, Dict, Optional を使用
from typing import List, Dict, Optional, Any

def process_data(self, items: List[str]) -> Optional[Dict[str, Any]]:
    pass
```

### 複雑な型ヒント
```python
from typing import Union, Tuple, Callable

# Union型
def method(self, value: Union[str, int]) -> str:
    pass

# Tuple型
def get_coordinates(self) -> Tuple[float, float]:
    pass

# Callable型
def apply_function(self, func: Callable[[int], int]) -> int:
    pass
```

## エラーハンドリング

### 基本パターン
```python
try:
    # 処理
    result = operation()
    
except SpecificException as e:
    # 特定のエラーを個別に処理
    logger.error(f"特定のエラー: {e}")
    raise
    
except Exception as e:
    # その他すべてのエラー
    logger.error(f"予期しないエラー: {e}")
    raise
    
finally:
    # クリーンアップ処理（必要な場合）
    cleanup()
```

### ErrorHandlerの使用
```python
from utils.error_handler import ErrorHandler

try:
    result = operation()
except Exception as e:
    error_info = error_handler.handle_error(e, {
        "step": "step_name",
        "context": "additional_context"
    })
    raise Exception(f"処理に失敗しました: {e}")
```

### RetryHandlerの使用
```python
from utils.error_handler import RetryHandler

retry_handler = RetryHandler(logger, max_retries=3, delay=2.0)

# 非同期関数のリトライ
result = await retry_handler.retry_async(
    some_async_function,
    arg1,
    arg2
)

# 同期関数のリトライ
result = retry_handler.retry_sync(
    some_sync_function,
    arg1,
    arg2
)
```

## ログ出力

### 基本的なログレベル
```python
logger.debug("デバッグ情報")      # 開発時の詳細情報
logger.info("情報メッセージ")     # 通常の情報
logger.warning("警告メッセージ")  # 警告
logger.error("エラーメッセージ")  # エラー
logger.critical("重大なエラー")   # 重大なエラー
```

### 絵文字の使用（推奨）
```python
logger.info("🚀 処理を開始します")
logger.info("✅ 処理が完了しました")
logger.error("❌ エラーが発生しました")
logger.warning("⚠️ 警告: XXX")
logger.info("📊 データを取得しました")
logger.info("🎤 音声を生成しました")
logger.info("🎬 動画を生成しました")
logger.info("☁️ アップロードしました")
logger.info("📝 記録しました")
logger.info("🎉 完了しました")
```

### 変数を含むログ
```python
# f-stringを使用
logger.info(f"処理完了: {count}件")

# 詳細情報を含める
logger.info(f"ファイルを保存しました: {file_path} ({file_size}MB)")

# エラー時は詳細を記録
logger.error(f"ファイル読み込みエラー: {file_path}, エラー: {e}")
```

## ファイル操作

### Pathオブジェクトの使用（必須）
```python
from pathlib import Path

# ✅ OK
file_path = Path("temp") / "output.txt"
if file_path.exists():
    content = file_path.read_text()

# ❌ NG
file_path = "temp/output.txt"  # 文字列は使わない
```

### ファイル存在チェック
```python
from pathlib import Path

file_path = Path("assets/background.png")

if not file_path.exists():
    raise FileNotFoundError(f"ファイルが見つかりません: {file_path}")

# ディレクトリ作成
output_dir = Path("output")
output_dir.mkdir(parents=True, exist_ok=True)
```

### ファイル読み書き
```python
from pathlib import Path

# テキストファイル
file_path = Path("data.txt")
content = file_path.read_text(encoding='utf-8')
file_path.write_text(content, encoding='utf-8')

# バイナリファイル
file_path = Path("data.bin")
data = file_path.read_bytes()
file_path.write_bytes(data)

# with文を使用（推奨）
with open(file_path, 'r', encoding='utf-8') as f:
    content = f.read()
```

## 非同期処理

### asyncio の使用
```python
import asyncio

# 複数のタスクを並列実行
tasks = [
    async_task_1(),
    async_task_2(),
    async_task_3()
]
results = await asyncio.gather(*tasks)

# タイムアウト付き実行
try:
    result = await asyncio.wait_for(async_task(), timeout=30.0)
except asyncio.TimeoutError:
    logger.error("タイムアウトしました")
```

### 並列処理の制限
```python
import asyncio

# セマフォで並列数を制限
semaphore = asyncio.Semaphore(3)  # 最大3並列

async def limited_task():
    async with semaphore:
        result = await actual_task()
    return result

tasks = [limited_task() for _ in range(10)]
results = await asyncio.gather(*tasks)
```

## 辞書・リスト操作

### 辞書の安全な取得
```python
# ✅ OK: getを使用（デフォルト値指定）
value = data.get("key", "default_value")
count = data.get("count", 0)

# ❌ NG: 直接アクセス（KeyErrorのリスク）
value = data["key"]
```

### 辞書の結合
```python
# ✅ OK: Python 3.9+
merged = dict1 | dict2

# ✅ OK: 互換性重視
merged = {**dict1, **dict2}

# ✅ OK: updateを使用
merged = dict1.copy()
merged.update(dict2)
```

### リスト内包表記
```python
# ✅ OK: 読みやすい
numbers = [x * 2 for x in range(10) if x % 2 == 0]

# ❌ NG: 複雑すぎる（for文を使用）
result = [process(x) for sublist in data for x in sublist if condition(x)]
```

## 文字列操作

### f-stringの使用（推奨）
```python
# ✅ OK: f-string
message = f"Hello, {name}! You have {count} messages."

# ❌ NG: format()
message = "Hello, {}! You have {} messages.".format(name, count)

# ❌ NG: %演算子
message = "Hello, %s! You have %d messages." % (name, count)
```

### 複数行文字列
```python
# ✅ OK: トリプルクォート
message = """
これは
複数行の
メッセージです
"""

# インデントを除去
from textwrap import dedent
message = dedent("""
    これは
    複数行の
    メッセージです
""").strip()
```

## 条件分岐

### if文の書き方
```python
# ✅ OK: 明確な条件
if value is not None:
    process(value)

# ✅ OK: 早期リターン
if not condition:
    return

# ❌ NG: ネストが深い
if condition1:
    if condition2:
        if condition3:
            process()  # ネストが深すぎる
```

### 三項演算子
```python
# ✅ OK: シンプルな場合
result = "Yes" if condition else "No"

# ❌ NG: 複雑な場合（if文を使用）
result = (complex_function1() if complex_condition() 
          else complex_function2())
```

## 命名規則

### クラス名
```python
# ✅ OK: パスカルケース
class UserManager:
    pass

class DataProcessor:
    pass
```

### 関数・メソッド名
```python
# ✅ OK: スネークケース
def process_data():
    pass

async def fetch_user_data():
    pass

def _private_method():
    pass
```

### 変数名
```python
# ✅ OK: スネークケース、説明的
user_count = 10
file_path = "data.txt"
is_valid = True

# ❌ NG: 短すぎる、説明不足
n = 10
fp = "data.txt"
f = True
```

### 定数
```python
# ✅ OK: 大文字スネークケース
MAX_RETRY_COUNT = 3
API_TIMEOUT = 30
DEFAULT_ENCODING = 'utf-8'
```

## 禁止事項

### 1. グローバル変数の使用禁止
```python
# ❌ NG
global_counter = 0

def increment():
    global global_counter
    global_counter += 1
```

### 2. 可変デフォルト引数禁止
```python
# ❌ NG
def method(self, items=[]):  # リストをデフォルト引数にしない
    items.append(1)
    return items

# ✅ OK
def method(self, items: Optional[List] = None):
    if items is None:
        items = []
    items.append(1)
    return items
```

### 3. bare except禁止
```python
# ❌ NG
try:
    operation()
except:  # 何もキャッチしない
    pass

# ✅ OK
try:
    operation()
except Exception as e:
    logger.error(f"エラー: {e}")
    raise
```

### 4. print文の使用禁止
```python
# ❌ NG
print("デバッグ情報")

# ✅ OK
logger.debug("デバッグ情報")
```

## ベストプラクティス

### 1. コンテキストマネージャーの使用
```python
# ✅ OK: with文を使用
with open(file_path, 'r') as f:
    content = f.read()

with timer_context("処理名", logger):
    result = process()
```

### 2. 早期リターン
```python
# ✅ OK: 早期リターン
def process(data):
    if not data:
        return None
    
    if not validate(data):
        return None
    
    return transform(data)

# ❌ NG: ネストが深い
def process(data):
    if data:
        if validate(data):
            return transform(data)
    return None
```

### 3. リスト内包表記の適切な使用
```python
# ✅ OK: シンプルな変換
squares = [x**2 for x in range(10)]

# ✅ OK: フィルタリング付き
evens = [x for x in range(10) if x % 2 == 0]

# ❌ NG: 複雑すぎる（for文を使用）
result = [func(x, y, z) for x in list1 for y in list2 
          for z in list3 if condition(x, y, z)]
```

### 4. 明示的な比較
```python
# ✅ OK
if value is None:
    pass

if len(items) == 0:
    pass

# ❌ NG: 暗黙的な比較
if not value:  # Noneと0とFalseを区別できない
    pass
```

## コメント

### docstringは必須
すべてのクラス・メソッドにdocstringを記述してください。

### インラインコメント
```python
# ✅ OK: 理由を説明
result = value * 2  # 倍にする必要がある

# ❌ NG: 自明なことを説明
result = value * 2  # valueを2倍にする
```

### TODO コメント
```python
# TODO: エラーハンドリングを改善
# FIXME: メモリリークの可能性あり
# NOTE: この処理は遅いので要最適化
```

## チェックリスト

実装前に確認：
- [ ] 型ヒントを使用している
- [ ] docstringを記述している
- [ ] エラーハンドリングを実装している
- [ ] ログ出力を含めている
- [ ] 非同期メソッドは`async def`で定義している
- [ ] インポートの順序が正しい
- [ ] 命名規則に従っている
- [ ] 禁止事項を守っている
# コーディング規約

このファイルはYouTube AI Podcastプロジェクトのコーディング規約を定義します。
AIアシスタントは常にこの規約に従ってコードを生成・編集してください。

## 基本原則

1. **読みやすさ優先**: コードは人間が読むものです
2. **明示的に**: 暗黙的な動作は避ける
3. **エラーハンドリング必須**: すべての処理でエラーを適切に処理
4. **ログ出力必須**: 処理の開始・完了・エラーを必ずログに記録
5. **型ヒント使用**: 可能な限り型ヒントを使用

## ファイル構造

### インポートの順序（必須）
```python
# 1. 標準ライブラリ
import os
import sys
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime

# 2. サードパーティライブラリ
from dotenv import load_dotenv
import anthropic
import gspread

# 3. プロジェクト内インポート
from config.settings import Settings
from modules.xxx import Xxx
from utils.logger import setup_logger, get_logger
from utils.error_handler import ErrorHandler
from utils.timer import Timer, timer_context
```

### ファイルの先頭（必須）
```python
"""
モジュールの説明
"""
import 文...

# モジュールレベルのlogger取得
logger = get_logger(__name__)
```

## クラス定義

### クラスの基本構造
```python
class ClassName:
    """
    クラスの説明
    
    Attributes:
        attribute_name: 説明
    """
    
    def __init__(self, settings: Settings):
        """
        初期化
        
        Args:
            settings: アプリケーション設定
        """
        self.settings = settings
        # 初期化処理
        
    async def method_name(self, param: str) -> Dict[str, Any]:
        """
        メソッドの説明
        
        Args:
            param: パラメータの説明
            
        Returns:
            戻り値の説明
            
        Raises:
            Exception: エラーの説明
        """
        try:
            # 処理
            return result
        except Exception as e:
            logger.error(f"エラーメッセージ: {e}")
            raise
```

### 必須のdocstring形式
```python
"""
1行の要約

詳細な説明（必要に応じて）

Args:
    param1: パラメータ1の説明
    param2: パラメータ2の説明

Returns:
    戻り値の説明（型を含む）

Raises:
    ExceptionType: エラーが発生する条件
"""
```

## メソッド定義

### 非同期メソッド（推奨）
```python
async def method_name(self, param: str) -> Dict[str, Any]:
    """メソッドの説明"""
    with timer_context("処理名", logger):
        try:
            logger.info("🚀 処理を開始します")
            
            # メイン処理
            result = await some_async_operation(param)
            
            logger.info("✅ 処理が完了しました")
            return result
            
        except Exception as e:
            error_handler.handle_error(e, {"context": "method_name"})
            raise Exception(f"処理に失敗しました: {e}")
```

### 同期メソッド（必要な場合のみ）
```python
def method_name(self, param: str) -> Dict[str, Any]:
    """メソッドの説明"""
    try:
        logger.info("🚀 処理を開始します")
        
        # メイン処理
        result = some_operation(param)
        
        logger.info("✅ 処理が完了しました")
        return result
        
    except Exception as e:
        logger.error(f"❌ 処理に失敗しました: {e}")
        raise
```

### プライベートメソッド
```python
def _private_method(self, param: str) -> str:
    """
    内部処理用メソッド
    
    Note:
        このメソッドは外部から呼び出さないでください
    """
    # 処理
    return result
```

## 型ヒント

### 基本的な型ヒント
```python
# 必須: 引数と戻り値に型ヒント
def method(self, text: str, count: int) -> Dict[str, Any]:
    pass

# List, Dict, Optional を使用
from typing import List, Dict, Optional, Any

def process_data(self, items: List[str]) -> Optional[Dict[str, Any]]:
    pass
```

### 複雑な型ヒント
```python
from typing import Union, Tuple, Callable

# Union型
def method(self, value: Union[str, int]) -> str:
    pass

# Tuple型
def get_coordinates(self) -> Tuple[float, float]:
    pass

# Callable型
def apply_function(self, func: Callable[[int], int]) -> int:
    pass
```

## エラーハンドリング

### 基本パターン
```python
try:
    # 処理
    result = operation()
    
except SpecificException as e:
    # 特定のエラーを個別に処理
    logger.error(f"特定のエラー: {e}")
    raise
    
except Exception as e:
    # その他すべてのエラー
    logger.error(f"予期しないエラー: {e}")
    raise
    
finally:
    # クリーンアップ処理（必要な場合）
    cleanup()
```

### ErrorHandlerの使用
```python
from utils.error_handler import ErrorHandler

try:
    result = operation()
except Exception as e:
    error_info = error_handler.handle_error(e, {
        "step": "step_name",
        "context": "additional_context"
    })
    raise Exception(f"処理に失敗しました: {e}")
```

### RetryHandlerの使用
```python
from utils.error_handler import RetryHandler

retry_handler = RetryHandler(logger, max_retries=3, delay=2.0)

# 非同期関数のリトライ
result = await retry_handler.retry_async(
    some_async_function,
    arg1,
    arg2
)

# 同期関数のリトライ
result = retry_handler.retry_sync(
    some_sync_function,
    arg1,
    arg2
)
```

## ログ出力

### 基本的なログレベル
```python
logger.debug("デバッグ情報")      # 開発時の詳細情報
logger.info("情報メッセージ")     # 通常の情報
logger.warning("警告メッセージ")  # 警告
logger.error("エラーメッセージ")  # エラー
logger.critical("重大なエラー")   # 重大なエラー
```

### 絵文字の使用（推奨）
```python
logger.info("🚀 処理を開始します")
logger.info("✅ 処理が完了しました")
logger.error("❌ エラーが発生しました")
logger.warning("⚠️ 警告: XXX")
logger.info("📊 データを取得しました")
logger.info("🎤 音声を生成しました")
logger.info("🎬 動画を生成しました")
logger.info("☁️ アップロードしました")
logger.info("📝 記録しました")
logger.info("🎉 完了しました")
```

### 変数を含むログ
```python
# f-stringを使用
logger.info(f"処理完了: {count}件")

# 詳細情報を含める
logger.info(f"ファイルを保存しました: {file_path} ({file_size}MB)")

# エラー時は詳細を記録
logger.error(f"ファイル読み込みエラー: {file_path}, エラー: {e}")
```

## ファイル操作

### Pathオブジェクトの使用（必須）
```python
from pathlib import Path

# ✅ OK
file_path = Path("temp") / "output.txt"
if file_path.exists():
    content = file_path.read_text()

# ❌ NG
file_path = "temp/output.txt"  # 文字列は使わない
```

### ファイル存在チェック
```python
from pathlib import Path

file_path = Path("assets/background.png")

if not file_path.exists():
    raise FileNotFoundError(f"ファイルが見つかりません: {file_path}")

# ディレクトリ作成
output_dir = Path("output")
output_dir.mkdir(parents=True, exist_ok=True)
```

### ファイル読み書き
```python
from pathlib import Path

# テキストファイル
file_path = Path("data.txt")
content = file_path.read_text(encoding='utf-8')
file_path.write_text(content, encoding='utf-8')

# バイナリファイル
file_path = Path("data.bin")
data = file_path.read_bytes()
file_path.write_bytes(data)

# with文を使用（推奨）
with open(file_path, 'r', encoding='utf-8') as f:
    content = f.read()
```

## 非同期処理

### asyncio の使用
```python
import asyncio

# 複数のタスクを並列実行
tasks = [
    async_task_1(),
    async_task_2(),
    async_task_3()
]
results = await asyncio.gather(*tasks)

# タイムアウト付き実行
try:
    result = await asyncio.wait_for(async_task(), timeout=30.0)
except asyncio.TimeoutError:
    logger.error("タイムアウトしました")
```

### 並列処理の制限
```python
import asyncio

# セマフォで並列数を制限
semaphore = asyncio.Semaphore(3)  # 最大3並列

async def limited_task():
    async with semaphore:
        result = await actual_task()
    return result

tasks = [limited_task() for _ in range(10)]
results = await asyncio.gather(*tasks)
```

## 辞書・リスト操作

### 辞書の安全な取得
```python
# ✅ OK: getを使用（デフォルト値指定）
value = data.get("key", "default_value")
count = data.get("count", 0)

# ❌ NG: 直接アクセス（KeyErrorのリスク）
value = data["key"]
```

### 辞書の結合
```python
# ✅ OK: Python 3.9+
merged = dict1 | dict2

# ✅ OK: 互換性重視
merged = {**dict1, **dict2}

# ✅ OK: updateを使用
merged = dict1.copy()
merged.update(dict2)
```

### リスト内包表記
```python
# ✅ OK: 読みやすい
numbers = [x * 2 for x in range(10) if x % 2 == 0]

# ❌ NG: 複雑すぎる（for文を使用）
result = [process(x) for sublist in data for x in sublist if condition(x)]
```

## 文字列操作

### f-stringの使用（推奨）
```python
# ✅ OK: f-string
message = f"Hello, {name}! You have {count} messages."

# ❌ NG: format()
message = "Hello, {}! You have {} messages.".format(name, count)

# ❌ NG: %演算子
message = "Hello, %s! You have %d messages." % (name, count)
```

### 複数行文字列
```python
# ✅ OK: トリプルクォート
message = """
これは
複数行の
メッセージです
"""

# インデントを除去
from textwrap import dedent
message = dedent("""
    これは
    複数行の
    メッセージです
""").strip()
```

## 条件分岐

### if文の書き方
```python
# ✅ OK: 明確な条件
if value is not None:
    process(value)

# ✅ OK: 早期リターン
if not condition:
    return

# ❌ NG: ネストが深い
if condition1:
    if condition2:
        if condition3:
            process()  # ネストが深すぎる
```

### 三項演算子
```python
# ✅ OK: シンプルな場合
result = "Yes" if condition else "No"

# ❌ NG: 複雑な場合（if文を使用）
result = (complex_function1() if complex_condition() 
          else complex_function2())
```

## 命名規則

### クラス名
```python
# ✅ OK: パスカルケース
class UserManager:
    pass

class DataProcessor:
    pass
```

### 関数・メソッド名
```python
# ✅ OK: スネークケース
def process_data():
    pass

async def fetch_user_data():
    pass

def _private_method():
    pass
```

### 変数名
```python
# ✅ OK: スネークケース、説明的
user_count = 10
file_path = "data.txt"
is_valid = True

# ❌ NG: 短すぎる、説明不足
n = 10
fp = "data.txt"
f = True
```

### 定数
```python
# ✅ OK: 大文字スネークケース
MAX_RETRY_COUNT = 3
API_TIMEOUT = 30
DEFAULT_ENCODING = 'utf-8'
```

## 禁止事項

### 1. グローバル変数の使用禁止
```python
# ❌ NG
global_counter = 0

def increment():
    global global_counter
    global_counter += 1
```

### 2. 可変デフォルト引数禁止
```python
# ❌ NG
def method(self, items=[]):  # リストをデフォルト引数にしない
    items.append(1)
    return items

# ✅ OK
def method(self, items: Optional[List] = None):
    if items is None:
        items = []
    items.append(1)
    return items
```

### 3. bare except禁止
```python
# ❌ NG
try:
    operation()
except:  # 何もキャッチしない
    pass

# ✅ OK
try:
    operation()
except Exception as e:
    logger.error(f"エラー: {e}")
    raise
```

### 4. print文の使用禁止
```python
# ❌ NG
print("デバッグ情報")

# ✅ OK
logger.debug("デバッグ情報")
```

## ベストプラクティス

### 1. コンテキストマネージャーの使用
```python
# ✅ OK: with文を使用
with open(file_path, 'r') as f:
    content = f.read()

with timer_context("処理名", logger):
    result = process()
```

### 2. 早期リターン
```python
# ✅ OK: 早期リターン
def process(data):
    if not data:
        return None
    
    if not validate(data):
        return None
    
    return transform(data)

# ❌ NG: ネストが深い
def process(data):
    if data:
        if validate(data):
            return transform(data)
    return None
```

### 3. リスト内包表記の適切な使用
```python
# ✅ OK: シンプルな変換
squares = [x**2 for x in range(10)]

# ✅ OK: フィルタリング付き
evens = [x for x in range(10) if x % 2 == 0]

# ❌ NG: 複雑すぎる（for文を使用）
result = [func(x, y, z) for x in list1 for y in list2 
          for z in list3 if condition(x, y, z)]
```

### 4. 明示的な比較
```python
# ✅ OK
if value is None:
    pass

if len(items) == 0:
    pass

# ❌ NG: 暗黙的な比較
if not value:  # Noneと0とFalseを区別できない
    pass
```

## コメント

### docstringは必須
すべてのクラス・メソッドにdocstringを記述してください。

### インラインコメント
```python
# ✅ OK: 理由を説明
result = value * 2  # 倍にする必要がある

# ❌ NG: 自明なことを説明
result = value * 2  # valueを2倍にする
```

### TODO コメント
```python
# TODO: エラーハンドリングを改善
# FIXME: メモリリークの可能性あり
# NOTE: この処理は遅いので要最適化
```

## チェックリスト

実装前に確認：
- [ ] 型ヒントを使用している
- [ ] docstringを記述している
- [ ] エラーハンドリングを実装している
- [ ] ログ出力を含めている
- [ ] 非同期メソッドは`async def`で定義している
- [ ] インポートの順序が正しい
- [ ] 命名規則に従っている
- [ ] 禁止事項を守っている
